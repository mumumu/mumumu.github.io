<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tips | mumumu の日記]]></title>
  <link href="http://mumumu.github.io/blog/categories/tips/atom.xml" rel="self"/>
  <link href="http://mumumu.github.io/"/>
  <updated>2018-02-25T00:42:31+09:00</updated>
  <id>http://mumumu.github.io/</id>
  <author>
    <name><![CDATA[mumumu(Yoshinari Takaoka)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux で Mac のようにスクリーンショットを撮る]]></title>
    <link href="http://mumumu.github.io/blog/2018/02/24/linux-de-mac-falseyounisukurinsiyotutowocuo-ru/"/>
    <updated>2018-02-24T23:29:00+09:00</updated>
    <id>http://mumumu.github.io/blog/2018/02/24/linux-de-mac-falseyounisukurinsiyotutowocuo-ru</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/naelstrof/maim">https://github.com/naelstrof/maim</a></p>

<p>職場で Mac をデフォルトで充てがわれることが多くなり、スクリーンショットを撮るのに Cmd+Shift+4 するのに慣れてしまった。そんな自分が、Linux で同じことをしたくなったときどうするか？</p>

<p>基本的には、以下のようになる。</p>

<p>A) 範囲指定でスクリーンショットを撮ることが出来るプログラムを探し、インストールする<br/>
　 但し、GUI が呼ばれるプログラムは不可。CLI である必要がある<br/>
B) 上記を呼び出すようにショートカットキーを割り当てる</p>

<p>だが、1. を満たすプログラムがなかなか見つからない。どれも GUI を呼ぶか、範囲指定ができてもborderがわからなかったりするなど使いにくいものばかりだった。 <a href="https://wiki.archlinux.org/index.php/taking_a_screenshot">Arch Linux のページ</a> にあるソフトウェアをもろもろ調べ、結局選んだのが maim だった。</p>

<p>だが、こいつが Ubuntu だけ何故かパッケージが用意されていなかった(注1)ので、git リポジトリから最新版をインストールする羽目に。いろいろ依存していてビルドが大変だったが、Ubuntu 16.04 LTS では以下をインストールすれば(注2)、あとは <a href="https://github.com/naelstrof/maim#install-using-cmake-requires-cmake-git-libxrander-libxfixes-libglm">指示通りにすれば</a> インストールできる。</p>

<pre><code>$ sudo apt-get install  cmake libxrender-dev libxfixes-dev libglm-dev libglew-dev libglfw3-dev libgles2-mesa-dev libx11-dev libxcomposite-dev
</code></pre>

<p>あとは、以下のコマンドを Ctrl+Shift+F4 にマッピングした。</p>

<pre><code>$ maim -s ~/screenshot-$(date +%s).png
</code></pre>

<p>自分は KDE を使っているので <a href="https://docs.kde.org/trunk5/en/kde-workspace/kcontrol/khotkeys/manage.html#manage-add-shortcut">Command/URL を選んで Custom Shortcutを割り当てる</a> 方法を使ったが、他のデスクトップ環境でも似たような機能はきっとあるだろう。</p>

<p>(注1) 他の主要ディストリビューションにはある (Debian 含) のに、Ubuntu だけ何故... (´ー｀; )<br/>
(注2) 他に必要なものもあるかもしれない。build-essential とかは当然の前提よ(*゜ー゜)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[restore github page from source branch]]></title>
    <link href="http://mumumu.github.io/blog/2015/04/26/restore-github-page-from-source-branch/"/>
    <updated>2015-04-26T07:17:00+09:00</updated>
    <id>http://mumumu.github.io/blog/2015/04/26/restore-github-page-from-source-branch</id>
    <content type="html"><![CDATA[<p>github page を <a href="http://octopress.org/">Octopress</a> で公開している人は、きっと master が HTML と CSS だけで出来たリポジトリを github に持っており、かつ source ブランチでそれを生成するための Rakefile や <code>_config.yml</code>、ブログエントリの markdown、テーマなどをバックアップしているはずだ。</p>

<p>では、何かの拍子にブログを書く環境を壊してしまい、source ブランチから復活させなければならなくなった場合はどうだろうか。今朝ちょうどそういう状況に陥ってしまい、復旧に少し手間取ったのでメモしておく。</p>

<p>要するに clone した後、 <code>_deploy</code> ディレクトリを生成し、そこで git リポジトリを再初期化し、github page へのリポジトリを remote に加えるだけだ。 要するに、 <a href="https://github.com/imathis/octopress/blob/5080107cb9e4c7bad8feb719f7e57c1da3b20c65/Rakefile#L352">setup_github_pagesタスクの後半</a> を真似ただけである。</p>

<pre><code>$ git clone git@github.com:mumumu/mumumu.github.io.git blog
$ cd blog
$ mkdir _deploy
$ cd _deploy
$ git init
$ git remote add origin git@github.com:mumumu/mumumu.github.io
</code></pre>

<p>あとは <code>rake new_post["some title"]</code> で記事を書き、<code>rake generate</code> や <code>rake gen_deploy</code> の操作でいつも通り記事が公開できるようになる。</p>

<p>こうしたリストアの操作と、 <code>git push origin source</code> というバックアップ操作が面倒くさかったので、以下のような patch を Rakefile に足しておいた。</p>

<p>まずは バックアップの操作が <code>rake gen_deploy</code>後に自動で行われるようにした。</p>

<pre><code class="diff">@@ -252,16 +252,38 @@ multitask :push do
   Rake::Task[:copydot].invoke(public_dir, deploy_dir)
   puts "\n## copying #{public_dir} to #{deploy_dir}"
   cp_r "#{public_dir}/.", deploy_dir
+  message = "Site updated at #{Time.now.utc}"
   cd "#{deploy_dir}" do
     system "git add ."
     system "git add -u"
     puts "\n## Commiting: Site updated at #{Time.now.utc}"
-    message = "Site updated at #{Time.now.utc}"
     system "git commit -m \"#{message}\""
     puts "\n## Pushing generated #{deploy_dir} website"
     system "git push origin #{deploy_branch} --force"
+  end
+
+  cd "#{deploy_dir}/../source" do
+    system "git add *"
+    puts "\n## Commiting: Site updated at #{Time.now.utc}"
+    system "git commit -m \"#{message}\""
+    puts "\n## Pushing source branch as backup"
+    system "git push origin source"
     puts "\n## Github Pages deploy complete"
   end
+
+end
</code></pre>

<p>github page のソースを clone した後、<code>_deploy</code> ディレクトリを再生成し、master として remote を足すタスクも追加した。</p>

<pre><code class="diff">+
+desc "restore github pages directory"
+task :restore_github_pages_directory do
+  puts "\n## Re-creating deploy directory"
+  rm_rf deploy_dir
+  mkdir_p deploy_dir
+
+  cd "#{deploy_dir}" do
+    repo_url = "git@github.com:mumumu/mumumu.github.io"
+    system "git init"
+    system "git remote add origin #{repo_url}"
+  end
+ end

 desc "Update configurations to support publishing to root or sub directory"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[seq -w and zero padding]]></title>
    <link href="http://mumumu.github.io/blog/2014/01/20/seq-w/"/>
    <updated>2014-01-20T12:03:00+09:00</updated>
    <id>http://mumumu.github.io/blog/2014/01/20/seq-w</id>
    <content type="html"><![CDATA[<p><a href="http://linuxjm.sourceforge.jp/html/gnumaniak/man1/seq.1.html">http://linuxjm.sourceforge.jp/html/gnumaniak/man1/seq.1.html</a><br/>
<a href="http://at-aka.blogspot.jp/2006/11/seq-0-padding.html">http://at-aka.blogspot.jp/2006/11/seq-0-padding.html</a></p>

<p>seq(1) ってコマンドラインから連番を作るときにとても便利だ。ただ、この値を0埋めしたいときがある。<br/>
その場合は -w オプションを付けろといろんなブログに書いてある。以下のような具合だ。</p>

<pre><code>$ seq -w 1 10
01
02
03
04
05
06
07
08
09
10
</code></pre>

<p>けど、これは指定する最大値が二桁以上の場合だ。上記の 10 を一桁の値、たとえば 5 に変えるとうまくいかなくなる。</p>

<pre><code>$ seq -w 1 5
1
2
3
4
5
</code></pre>

<p>これは -w オプションが最大の桁数に合わせて0埋めするためだ。だから、以下のようにすると同じように通用する。</p>

<pre><code>$ seq -w 01 5
01
02
03
04
05
</code></pre>

<p>最初 -f オプションでフォーマットしようかと思ったのだけど、printf の %d を指定すると以下のように怒られる。<br/>
これは、数値を内部的に浮動小数点で扱っているためだった。 <a href="http://linuxjm.sourceforge.jp/html/gnumaniak/man1/seq.1.html">マニュアル</a> にもしっかり書いてある。</p>

<pre><code>$ seq -f "%02d" 01 5
seq: FORMAT `%02d' に不明な %d 指定があります
</code></pre>

<p>なので、g を指定してあげるとちゃんとうまくいく。</p>

<pre><code>$ seq -f "%02g" 1 5
01
02
03
04
05
</code></pre>

<p>まあ、以下が一番スマートかなー、と思う次第(*´〜｀)</p>

<pre><code>$ seq -w 01 5
01
02
03
04
05
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tiarra over SSL without stone]]></title>
    <link href="http://mumumu.github.io/blog/2013/12/24/tiarra-over-ssl/"/>
    <updated>2013-12-24T00:08:00+09:00</updated>
    <id>http://mumumu.github.io/blog/2013/12/24/tiarra-over-ssl</id>
    <content type="html"><![CDATA[<p><a href="http://www.clovery.jp/tiarra/">Tiarra</a> といえば Perl で書かれた日本では著名な IRC Proxy であるが、<a href="https://www.google.co.jp/search?q=tiarra+ssl&amp;amp;oq=tiarra+ssl">SSL 経由で接続しようと思ってぐぐる</a> と 「<a href="http://www.gcd.org/sengoku/stone/Welcome.ja.html">stone</a> 経由で接続する」 Howto がたくさん出てくる。果ては tiarra では SSL 接続できないから znc に移行した。とかいうエントリまで出てくる。</p>

<p>けれども、Tiarra のソースをちょこっと読んでみると綺麗にモジュール化されており、ソケット周りも綺麗にラップされてるので、簡単なソース変更でSSL接続ができるんじゃないか。というか、ここまでやる以上、作者である <a href="http://www.clovery.jp/">Topiaたん</a> がそれを意図して書かないわけがない。と思った。</p>

<p>そこで、<a href="http://search.cpan.org/~sullr/IO-Socket-SSL-1.962/">IO::Socket::SSL</a> で <a href="http://coderepos.org/share/browser/lang/perl/tiarra">tiarra の現時点での最新ソース</a> (rev.39276) を <a href="https://github.com/ggreer/the_silver_searcher">ag(Silver Searcher)</a> すると、 main/Tiarra/Socket/Connect.pm の _check_connect_dependency 関数に以下のようにある。</p>

<pre><code>sub _check_connect_dependency {
    my $this = shift;

    my $ssl = $this-&gt;current_ssl;
    if (defined $ssl &amp;&amp; $ssl-&gt;{version}) {
        if (!Tiarra::OptionalModules-&gt;ssl) {
            $this-&gt;_warn(
                qq{You wants to connect with SSL, }.
                    qq{but SSL support is not enabled. }.
                        qq{Use non-SSL or install IO::Socket::SSL if possible.\n});
            return 0;
        }
    }
    return 1;
}
</code></pre>

<p>$ssl と $ssl->{version} が定義されていれば SSL 接続に行くらしい。
$ssl = $this-&gt;current_ssl なので、それを見ると</p>

<pre><code>sub current_ssl {
    my $this = shift;

    utils-&gt;get_first_defined(
        $this-&gt;{connecting}-&gt;{ssl},
        $this-&gt;ssl);
}
</code></pre>

<p>てな感じで、 $this-&gt;{connecting} に ssl が定義されてると、それを返すらしい。
$this-&gt;connecting の中身は、下のようになっている。</p>

<pre><code>$this-&amp;gt;{connecting} = shift @{$this-&amp;gt;{queue}};
</code></pre>

<p>$this-&gt;{queue} の中身は以下のようになっている。どうやら接続オプションを渡すようだ。</p>

<pre><code>        foreach my $port (@ports) {
            push (@{$this-&gt;{queue}},
                  map {
                      $struct = {
                          type =&gt; $sock_type,
                          addr =&gt; $_,
                          port =&gt; $port,
                      };
                  } @{$addrs_by_types{$sock_type}});
        }
</code></pre>

<p>じゃあ多分接続オプションって tiarra.conf に書けるよね、と思ったら、<a href="http://coderepos.org/share/browser/lang/perl/tiarra/trunk/all.conf#L296">all.conf</a> にあった。
これを参考にして ssl ブロック以下を接続に追記すると、あっさり stone なしで接続できた。
ただし、IO::Socket::SSL(と Net::SSLeay) が必要です。</p>

<p>verify オプションはデフォルト有効になっているので、証明書の検証に失敗して対処法がわからないようであれば no を指定してみると良いと思います。たとえば SSL が有効な freenode サーバに接続するなら、自分は今以下のように指定しています。(Debian GNU/Linux 7.3 wheezy の環境)</p>

<pre><code>freenode {
  #  IP アドレスを指定すると名前解決が行われてエラーになる
  #  その場合は hosts の類に名前を書いてあげて、それを指定
  #  するようにする
  host: irc.freenode.net
  port: 7000

  ssl {
      version: sslv23
      ca-path: /etc/ssl/certs
  }
</code></pre>

<p>但し、host に IP アドレスを指定すると、 main/Tiarra/Resolver.pm で必要ない名前解決をしに行くためエラーになります(多分バグ)。そのため、host に IP アドレスを指定したくなった場合は hosts に類するものに適当な名前を書いてあげて、それを host の設定に指定すると繋がるようになります。</p>

<h3>まとめ</h3>

<p>・ tiarra は 別に stone なしでも SSL 接続できる<br/>
・ 要 IO::Socket::SSL(と Net::SSLeay)<br/>
・ 必要な設定は最低限以下。 それ以外の設定は all.conf を参照。</p>

<pre><code>ssl {
    version: sslv23

    # CA 鍵リストファイル。
    # verify (デフォルト有効)を行う場合は ca-file か ca-path の
    # どちらかを必ず指定してください。
    #ca-file: /usr/local/share/certs/ca-root-nss.crt

    # CA 鍵パス
    # verify (デフォルト有効)を行う場合は ca-file か ca-path の
    # どちらかを必ず指定してください。
    #ca-path: /etc/ssl/certs

    #  ca-path や ca-file を指定してもどうしても接続できない場合指定
    #verify: no
}
</code></pre>

<p>・<a href="http://znc.in/">znc</a> 皆いいとか言ってるけど日本語の扱いイマイチだしその他細かいところも気に入らないしなんでC++なのか意味わかんないしで tiarra を維持できた自分はとても幸せです。</p>

<p>・どうでもいいけど <a href="http://coderepos.org/">CodeRepos</a> 落ちすぎな気がします。</p>

<p><strong>[ Update December 24th 23:34 JST by m ]</strong></p>

<p>Tiarra の作者の Topia たんから verify:no の件についていろいろ指摘を貰いました。 ca-path または ca-file で証明書のパスを指定しておかなかなったので verify に失敗していました。Debian GNU/Linux 7.3 wheezy の自分の環境では、ca-certificates パッケージと ssl-certs パッケージを入れて、 ca-path を指定すると freenode に verify した上で繋がるようになりました。</p>

<p>これを踏まえて、「まとめ」と freenode の接続例を更新しておきました。 <a href="http://www.clovery.jp/">Topiaたん</a> ありがとう！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debugging server with strace]]></title>
    <link href="http://mumumu.github.io/blog/2013/10/13/debugging-server-with-strace/"/>
    <updated>2013-10-13T02:20:00+09:00</updated>
    <id>http://mumumu.github.io/blog/2013/10/13/debugging-server-with-strace</id>
    <content type="html"><![CDATA[<iframe src="http://www.slideshare.net/slideshow/embed_code/27094034" width="427" height="356" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>


<p><br />
<br /><br/>
社内LT で strace について喋ったので記録しておく。</p>

<p>結構噛み砕いて喋ったつもりだし、自分はこれくらいまで噛み砕かないと多分人前では喋らないんだろうな、という実感が得られたトークでもあった。幸い好評だったようなので、ここに貼る次第だ。</p>

<p>今度は統計の話でもトークしてみたいと思う。これくらいの噛み砕き具合で(*´～｀)</p>
]]></content>
  </entry>
  
</feed>
